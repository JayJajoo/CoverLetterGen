combined_resume_content = """**Candidate Information**  
- Name: Jay Jajoo  
- Phone: +1-857-351-1933  
- Email: jayjajoo02@gmail.com  
- LinkedIn: https://www.linkedin.com/in/jay-jajoo-64958b15a  
- GitHub: https://github.com/JayJajoo  

---

**Skills**  
- Languages: Python, Javascript, C++, Java, HTML, CSS, MySQL, C  
- Frameworks: Flask, React, Node.js, Express.js, MongoDB, SOAP, REST API’s, Full Stack Development, Backend Development, Encryption  
- Libraries: TensorFlow, PyTorch, NumPy, Pandas, Scikit-learn, Keras, NLTK, PySpark, LLM, RAG’s, Computer Vision, Material UI, TailwindCSS, Bootstrap  
- Data & Cloud Tools: AWS (S3, EC2, Glue, Athena), Snowflake, Google Colab, Kaggle, Git, VS Code, Tableau, Power BI, Excel  
- Additional Skills: Data Modeling, Big Data Processing, Cloud Computing, Distributed Systems, Warehousing, Feature Engineering, Predictive Modeling, Statistical Analysis, Deep Learning, Web Development, Software Engineering, Human-Computer Interaction, Encryption  

---

**Education**  
- Northeastern University (Khoury College), Boston, MA  
  - M.S. in Data Science (Sept 2024 – Dec 2026)  
  - CGPA: 4.0/4.0  
  - Course Work: NLP, Algorithms, Supervised Machine Learning, Data Management and Preprocessing  
- Vellore Institute of Technology, Tamil Nadu, India  
  - B.Tech. in Computer Science and Engineering (Sept 2020 – May 2024)  
  - CGPA: 9.05/10  
  - Course Work: Machine Learning, Statistics, DBMS, OS, COA, DSA, Parallel Programming and Paradigms  

---

**Experience**  
- **Data Science Intern** — Imagine Web Technologies (Jan 2024 – Jul 2024)  
  - Curated, refined, and processed customer data via ETL pipelines. Conducted exploratory data analysis (EDA) to extract insights. Engineered features for predictive models.  
  - Developed and deployed a Feedforward Neural Network in PyTorch, achieving an F1 score of 0.89 for customer conversion prediction, optimizing architecture and hyperparameters.

- **Web Developer Intern** — Imagine Web Technologies (Jan 2024 – Jul 2024)  
  - Developed features with MERN stack, improving user engagement by 10%.  
  - Created CI/CD pipelines, optimized application performance, and implemented dashboards to enhance user experience.  

---

**Projects**  

***Corrective RAG-Based QA System***

  * Built a highly advanced Retrieval-Augmented Generation (RAG) QA system that leverages structured agents in LangGraph and LangChain to dynamically route user queries based on intent detection. The system intelligently decides between using vector search, live web search via Tavily-style tools, or a hybrid of both. It includes query rephrasing for context preservation and document relevancy scoring to ensure accurate responses. Deployed a robust interface using Streamlit on Render, supporting file uploads and real-time web queries. The project achieved a **97% QA accuracy** with just **$0.11 per million tokens**, demonstrating both scalability and cost-effectiveness.

***Spelling Correction and Next-Word Prediction System***

  * Developed a dual-purpose NLP model: a **Siamese Network-based spelling corrector** and a **Bi-LSTM-based next-word predictor**, trained on a custom dataset of over 6 million rows. Achieved **99.5% correction accuracy** and **next-word perplexity of 2**, making it exceptionally precise. Built a responsive full-stack React web interface, exposing both models via a RESTful Flask API with an average response time of just **2 milliseconds**, enabling near real-time performance. This was part of the CS6120 NLP course project.

***Home Anomaly Detection***

  * Collected and cleaned data from 30 log files related to smart home devices. After preprocessing and feature extraction, trained and compared multiple anomaly detection models: Isolation Forest, DBSCAN, and an LSTM Autoencoder. The LSTM model significantly outperformed others, minimizing reconstruction error and achieving robust anomaly classification. A dynamic threshold was defined using the **95th percentile**, leading to a precise cutoff of **0.016%** for anomaly detection. Resulted in a reliable detection system for unusual home behaviors or potential intrusions.

***Object Detection and 3D Coordinates Prediction for Autonomous Driving***

  * Implemented a real-time 3D perception pipeline for autonomous driving. Combined **YOLOv8 for object detection** with **MiDaS depth estimation**, allowing for spatial positioning of detected objects. Addressed challenges in depth estimation with improvements that brought down average depth prediction errors (\~130 meters/image). After multiple YOLO model trainings, **YOLOv8 Medium** without augmentation emerged as the best model with **Precision: 0.9418**, **Recall: 0.8908**, **mAP\@0.5: 0.9391**, and **mAP\@0.5:0.9: 0.889**, demonstrating robust accuracy in real-time object localization.

***Fungi Classification Using Deep Learning***

  * Designed and trained a deep CNN (based on ResNet) to classify various fungi species with **98.90% accuracy**. Hyperparameter tuning across multiple models (ResNet50, VGG16, IncV3) was performed, achieving **92.29% validation accuracy** and **90.46% precision**. The project culminated in a **research paper accepted by Springer IDBA 2024**, where it received praise for its novel approach. Over 85% of conference attendees expressed interest in future collaboration, indicating strong practical relevance.

***Metamorphic Malware Detection Using RNNs***

  * Focused on detecting evasive metamorphic malware using advanced RNN architectures. Compared multiple RNN variants (LSTM, Bi-LSTM, GRU) and hybridized their features to increase detection accuracy. Achieved a **93.25% accuracy**, significantly outperforming baselines. Visualization of execution patterns and system calls was used for feature analysis. Results were presented in a peer-reviewed paper published at **IEEE ICDSNS 2023**, receiving positive academic recognition.

***Simplify Amazon – Review Analysis and Summarization Tool***

  * Built a browser-based review analytics tool that scrapes Amazon product reviews, performs **sentiment classification (91% accuracy)** using logistic regression, and generates natural-language summaries via **OpenAI’s GPT**. Visualization with D3.js and Chart.js enabled intuitive representation of sentiment trends and keyword distribution. Reduced manual product analysis time by **25%**, offering a faster way to assess public perception of products.

***Mental Health Chatbot***

  * Developed an intent-based chatbot providing real-time assistance for mental health queries such as sleep, stress, anxiety, and substance use. Trained using conversational neural networks to simulate empathy and engagement, the bot reduced response latency and diagnosis time by **10%**. Covered over 20 distinct intents with adaptive dialog flow, leading to a **70% user satisfaction** score in beta testing.

***Garments E-Commerce Platform***

  * Built a scalable e-commerce platform for Jay Garments India Pvt. Ltd. using the **MERN stack and AWS**. Integrated secure user flows including authentication, cart, and payments via **Cashfree**. Developed admin panels with full CRUD support for product, inventory, and order management. Key features included **dynamic GST calculation**, **real-time stock updates**, and **email-based stock alerts**, boosting operational efficiency by over **20%** and improving stock reliability.

***Real-Time Secure Chat Application***

  * Engineered a secure real-time messaging platform using **Socket.IO** for bidirectional communication and **AES encryption** for message security. Implemented features like message recall, read receipts, notification popups, and user status tracking. Built a sleek React interface and ensured seamless real-time UX across desktop and mobile devices. Emphasized end-to-end data privacy, making it suitable for enterprise use cases.


---

**Achievements**  
- Certified AWS Solutions Architect with a score of 793/1000, demonstrating skills in EC2, S3, Lambda, DynamoDB, etc.  
- Published research paper at IEEE ICDSNS 2023 titled *"Performance Comparison of RNNs for Metamorphic Malwares"* in IEEE indexed proceedings.  
"""

code3  = """from docx import Document
from docx.shared import Pt
from docx.enum.text import WD_ALIGN_PARAGRAPH
import os

# Create a new Word Document
doc = Document()

# 1. Title: Candidate name in font size 32, centered
title = doc.add_paragraph()
run_title = title.add_run("[CANDIDATE_NAME]")
run_title.font.size = Pt(32)
run_title.bold = True
title.alignment = WD_ALIGN_PARAGRAPH.CENTER

# 2. Contact information: centered
contact_info_text = "[CANDIDATE_EMAIL] | [CANDIDATE_PHONE] | [CANDIDATE_LOCATION]"
contact_para = doc.add_paragraph()
contact_para.alignment = WD_ALIGN_PARAGRAPH.CENTER
contact_run = contact_para.add_run(contact_info_text)
contact_run.font.size = Pt(12)

# 3. Horizontal line
line = doc.add_paragraph()
line.add_run('_' * 100)

# 4. Greeting
greeting = "[GREETING]"
greeting_para = doc.add_paragraph()
greeting_para.add_run(greeting)
greeting_para.alignment = WD_ALIGN_PARAGRAPH.LEFT
greeting_para.paragraph_format.space_before = Pt(10)
greeting_para.paragraph_format.space_after = Pt(4)

# 5. Body Paragraph 1:
para1 = doc.add_paragraph()
para1.add_run("[PARAGRAPH_1]")
para1.paragraph_format.space_after = Pt(8)
para1.alignment = WD_ALIGN_PARAGRAPH.JUSTIFY

# 6. Body Paragraph 2:
para2 = doc.add_paragraph()
para2.add_run("[PARAGRAPH_2]")
para2.paragraph_format.space_after = Pt(8)
para2.alignment = WD_ALIGN_PARAGRAPH.JUSTIFY

# 7. Body Paragraph 3:
para3 = doc.add_paragraph()
para3.add_run("[PARAGRAPH_3]")
para3.paragraph_format.space_after = Pt(8)
para3.alignment = WD_ALIGN_PARAGRAPH.JUSTIFY


# 9. Closing
closing_lines = ["[CLOSING_LINE_1]", "[CLOSING_LINE_2]"]
for line_text in closing_lines:
    line_para = doc.add_paragraph()
    line_para.add_run(line_text)
    line_para.alignment = WD_ALIGN_PARAGRAPH.LEFT
    line_para.paragraph_format.space_after = Pt(2)

docx_filename = "cover_letter.docx"
    
if os.path.exists(docx_filename):
    os.remove(docx_filename)

# Save the document
doc.save(docx_filename)
"""

ctmp3 = """You are provided with a Python script that generates a Word document (.docx). Your task is to fill in all placeholders marked as [info to be filled] using information from the cover letter that should be written based on the user's resume and the provided job description.

Follow these strict instructions:

1. Do not fabricate any information. Use only what is present in the resume and job description and do not generate anything which the candidate has not done.

2. The body of the cover letter must contain exactly **three detailed and well-structured paragraphs** (not four):

3. The word limit for the entire paragraph section is a **maximum of 350 words**.

Paragraph 1: A compelling introduction and clear motivation for applying, aligned with the job description.

Paragraph 2: A thorough explanation of the candidate’s most relevant experience, skills, and projects directly aligned with the job description. Emphasize specific tools, technologies, achievements, and the candidate’s role and impact in each example.

Paragraph 3 (Final): A focused, polite, and professional thank-you paragraph that expresses appreciation for the opportunity, briefly reiterates enthusiasm for the role, and conveys interest in contributing to the company’s mission.

Replace all placeholders like [info to be filled] in the code with specific, accurate information derived from the resume and job description.

And finally end with a suitable, professional closing ("Best regards," and the candidate's name).

Return the complete filled exact Python script only, with no commentary, explanations, or content outside the code. Adhere strictly to the 3-paragraph structure and word limit.

[CODE]
{code}
================================================================
[JOB DESCRIPTION]:
{job_description}
================================================================
[RESUME]:
{combined_resume_content}
"""

code4  = """from docx import Document
from docx.shared import Pt
from docx.enum.text import WD_ALIGN_PARAGRAPH
import os

# Create a new Word Document
doc = Document()

# 1. Title: Candidate name in font size 32, centered
title = doc.add_paragraph()
run_title = title.add_run("[CANDIDATE_NAME]")
run_title.font.size = Pt(32)
run_title.bold = True
title.alignment = WD_ALIGN_PARAGRAPH.CENTER

# 2. Contact information: centered
contact_info_text = "[CANDIDATE_EMAIL] | [CANDIDATE_PHONE] | [CANDIDATE_LOCATION]"
contact_para = doc.add_paragraph()
contact_para.alignment = WD_ALIGN_PARAGRAPH.CENTER
contact_run = contact_para.add_run(contact_info_text)
contact_run.font.size = Pt(12)

# 3. Horizontal line
line = doc.add_paragraph()
line.add_run('_' * 100)

# 4. Greeting
greeting = "[GREETING]"
greeting_para = doc.add_paragraph()
greeting_para.add_run(greeting)
greeting_para.alignment = WD_ALIGN_PARAGRAPH.LEFT
greeting_para.paragraph_format.space_before = Pt(10)
greeting_para.paragraph_format.space_after = Pt(4)

# 5. Body Paragraph 1: Introduction and motivation
para1 = doc.add_paragraph()
para1.add_run("[PARAGRAPH_1]")
para1.paragraph_format.space_after = Pt(8)
para1.alignment = WD_ALIGN_PARAGRAPH.JUSTIFY

# 6. Body Paragraph 2: Relevant skills, experience, and projects
para2 = doc.add_paragraph()
para2.add_run("[PARAGRAPH_2]")
para2.paragraph_format.space_after = Pt(8)
para2.alignment = WD_ALIGN_PARAGRAPH.JUSTIFY

# 7. Body Paragraph 3: Current project aligned with job
para3 = doc.add_paragraph()
para3.add_run("[PARAGRAPH_3]")
para3.paragraph_format.space_after = Pt(8)
para3.alignment = WD_ALIGN_PARAGRAPH.JUSTIFY

# 8. Body Paragraph 4: Thank-you message
para4 = doc.add_paragraph()
para4.add_run("[PARAGRAPH_4]")
para4.paragraph_format.space_after = Pt(10)
para4.alignment = WD_ALIGN_PARAGRAPH.JUSTIFY

# 9. Closing
closing_lines = ["[CLOSING_LINE_1]", "[CLOSING_LINE_2]"]
for line_text in closing_lines:
    line_para = doc.add_paragraph()
    line_para.add_run(line_text)
    line_para.alignment = WD_ALIGN_PARAGRAPH.LEFT
    line_para.paragraph_format.space_after = Pt(2)

# Save the document
docx_filename = "cover_letter_[###USER_ID###].docx"
    
if os.path.exists(docx_filename):
    os.remove(docx_filename)
    
doc.save(docx_filename)
"""

ctmp4 = """You are provided with a Python script that generates a Word document (.docx). Your task is to fill in all placeholders marked as [info to be filled] using information from the cover letter that should be written based on the user's resume and the provided job description.

Follow these strict instructions:

Do not fabricate any information. Use only what is present in the resume and job description.

Only if necessary, you may include one realistic project that the candidate could plausibly be working on, based on their background and skills. This project must not be exaggerated or beyond the candidate’s capabilities.

The body of the cover letter must contain exactly four paragraphs, each very detailed and well-structured:

Paragraph 1: A compelling introduction and clear motivation for applying, aligned with the job description.

Paragraph 2: A thorough explanation of the candidate’s most relevant experience, skills, and projects related to the job.

Paragraph 3: A highlight of one strong existing or realistic ongoing project and how it connects with the job.

Paragraph 4: A polite and professional thank-you paragraph expressing appreciation and reiterating interest.

Replace all placeholders like [info to be filled] in the code with specific, accurate information derived from the resume and job description.

End with a suitable, professional closing ("Best regards," and the candidate's name).

Return the complete filled exact Python script only, with no commentary, explanations, or content outside the code.


[CODE]
{code}
================================================================
[JOB DESCRIPTION]:
{job_description}
================================================================
[RESUME]:
{combined_resume_content}
"""

# code  = """from docx import Document
# from docx.shared import Pt
# from docx.enum.text import WD_ALIGN_PARAGRAPH
# from docx2pdf import convert
# import os

# # Create a new Word Document
# doc = Document()

# # 1. Title: Candidate name in font size 32, centered
# title = doc.add_paragraph()
# run_title = title.add_run("[CANDIDATE_NAME]")
# run_title.font.size = Pt(32)
# run_title.bold = True
# title.alignment = WD_ALIGN_PARAGRAPH.CENTER

# # 2. Contact information: centered
# contact_info_text = "[CANDIDATE_EMAIL] | [CANDIDATE_PHONE] | [CANDIDATE_LOCATION]"
# contact_para = doc.add_paragraph()
# contact_para.alignment = WD_ALIGN_PARAGRAPH.CENTER
# contact_run = contact_para.add_run(contact_info_text)
# contact_run.font.size = Pt(12)

# # 3. Horizontal line
# line = doc.add_paragraph()
# line.add_run('_' * 100)

# # 4. Greeting
# greeting = "[GREETING]"
# greeting_para = doc.add_paragraph()
# greeting_para.add_run(greeting)
# greeting_para.alignment = WD_ALIGN_PARAGRAPH.LEFT
# greeting_para.paragraph_format.space_before = Pt(10)
# greeting_para.paragraph_format.space_after = Pt(4)

# # 5. Body Paragraph 1: Introduction and motivation
# para1 = doc.add_paragraph()
# para1.add_run("[PARAGRAPH_1]")
# para1.paragraph_format.space_after = Pt(8)
# para1.alignment = WD_ALIGN_PARAGRAPH.JUSTIFY

# # 6. Body Paragraph 2: Relevant skills, experience, and projects
# para2 = doc.add_paragraph()
# para2.add_run("[PARAGRAPH_2]")
# para2.paragraph_format.space_after = Pt(8)
# para2.alignment = WD_ALIGN_PARAGRAPH.JUSTIFY

# # 7. Body Paragraph 3: Current project aligned with job
# para3 = doc.add_paragraph()
# para3.add_run("[PARAGRAPH_3]")
# para3.paragraph_format.space_after = Pt(8)
# para3.alignment = WD_ALIGN_PARAGRAPH.JUSTIFY

# # 8. Body Paragraph 4: Thank-you message
# para4 = doc.add_paragraph()
# para4.add_run("[PARAGRAPH_4]")
# para4.paragraph_format.space_after = Pt(10)
# para4.alignment = WD_ALIGN_PARAGRAPH.JUSTIFY

# # 9. Closing
# closing_lines = ["[CLOSING_LINE_1]", "[CLOSING_LINE_2]"]
# for line_text in closing_lines:
#     line_para = doc.add_paragraph()
#     line_para.add_run(line_text)
#     line_para.alignment = WD_ALIGN_PARAGRAPH.LEFT
#     line_para.paragraph_format.space_after = Pt(2)

# if os.path.exists(docx_filename):
#     os.remove(docx_filename)

# if os.path.exists(pdf_filename):
#     os.remove(pdf_filename)
    
    
# # Save the document
# docx_filename = "cover_letter.docx"
# pdf_filename = "cover_letter.pdf"

# doc.save(docx_filename)
# convert(docx_filename)

# # Delete the original Word document after PDF conversion
# if os.path.exists(docx_filename):
#     os.remove(docx_filename)

# """
